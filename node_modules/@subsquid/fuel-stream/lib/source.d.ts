import { Logger } from '@subsquid/logger';
import { Range, FiniteRange } from '@subsquid/util-internal-range';
import { Block, FieldSelection } from './data/model';
import { ReceiptRequest, InputRequest, OutputRequest, TransactionRequest } from './data/data-request';
export interface GraphqlSettings {
    /**
     * GraphQL endpoint URL
     */
    url: string;
    /**
     * Maximum number of concurrent `blocks` queries.
     *
     * Default is `10`
     */
    strideConcurrency?: number;
    /**
     * `blocks` query size.
     *
     * Default is `5`.
     */
    strideSize?: number;
}
export interface GatewaySettings {
    /**
     * Subsquid Network Gateway url
     */
    url: string;
    /**
     * Request timeout in ms
     */
    requestTimeout?: number;
}
interface BlockRange {
    range?: Range;
}
/**
 * API and data that is passed to the data handler
 */
export interface DataHandlerContext<Store, F extends FieldSelection = {}> {
    /**
     * An instance of a structured logger.
     */
    log: Logger;
    /**
     * Storage interface provided by the database
     */
    store: Store;
    /**
     * List of blocks to map and process
     */
    blocks: Block<F>[];
    /**
     * Signals, that the processor reached the head of a chain.
     *
     * The head block is always included in `.blocks`.
     */
    isHead: boolean;
}
export type FuelBatchProcessorFields<T> = T extends DataSourceBuilder<infer F> ? F : never;
export declare class DataSourceBuilder<F extends FieldSelection = {}> {
    private requests;
    private fields?;
    private blockRange?;
    private gateway?;
    private graphql?;
    private running;
    private assertNotRunning;
    /**
     * Set Subsquid Network Gateway endpoint (ex Archive).
     *
     * Subsquid Network allows to get data from finalized blocks up to
     * infinite times faster and more efficient than via regular GraphQL.
     *
     * @example
     * processor.setGateway('https://v2.archive.subsquid.io/network/fuel-mainnet')
     */
    setGateway(url: string | GatewaySettings): this;
    /**
     * Set up GraphQL data ingestion
     */
    setGraphql(settings?: GraphqlSettings): this;
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     */
    setBlockRange(range?: Range): this;
    /**
     * Configure a set of fetched fields
     */
    setFields<F extends FieldSelection>(fields: F): DataSourceBuilder<F>;
    private add;
    /**
     * By default, the processor will fetch only blocks
     * which contain requested items. This method
     * modifies such behaviour to fetch all chain blocks.
     *
     * Optionally a range of blocks can be specified
     * for which the setting should be effective.
     */
    includeAllBlocks(range?: Range): this;
    addTransaction(options: TransactionRequest & BlockRange): this;
    addReceipt(options: ReceiptRequest & BlockRange): this;
    addInput(options: InputRequest & BlockRange): this;
    addOutput(options: OutputRequest & BlockRange): this;
    private getRequests;
    build(): DataSource<Block<F>>;
}
export interface DataSource<Block> {
    getFinalizedHeight(): Promise<number>;
    getBlockHash(height: number): Promise<string | undefined>;
    getBlocksCountInRange(range: FiniteRange): number;
    getBlockStream(fromBlockHeight?: number): AsyncIterable<Block[]>;
}
export type GetDataSourceBlock<T> = T extends DataSource<infer B> ? B : never;
export {};
//# sourceMappingURL=source.d.ts.map