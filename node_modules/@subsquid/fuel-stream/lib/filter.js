"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterBlockBatch = exports.filterBlock = void 0;
const util_internal_processor_tools_1 = require("@subsquid/util-internal-processor-tools");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_range_1 = require("@subsquid/util-internal-range");
class IncludeSet {
    constructor() {
        this.receipts = new Set();
        this.transactions = new Set();
        this.inputs = new Set();
        this.outputs = new Set();
    }
    addReceipt(receipt) {
        if (receipt) {
            this.receipts.add(receipt);
        }
    }
    addTransaction(tx) {
        if (tx) {
            this.transactions.add(tx);
        }
    }
    addInput(input) {
        if (input) {
            this.inputs.add(input);
        }
    }
    addOutput(output) {
        if (output) {
            this.outputs.add(output);
        }
    }
}
function buildReceiptFilter(dataRequest) {
    let receipts = new util_internal_processor_tools_1.EntityFilter();
    dataRequest.receipts?.forEach(req => {
        let { type, contract, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('receiptType', type);
        filter.propIn('contract', contract);
        receipts.add(filter, relations);
    });
    return receipts;
}
function buildTransactionFilter(dataRequest) {
    let transactions = new util_internal_processor_tools_1.EntityFilter();
    dataRequest.transactions?.forEach(req => {
        let { type, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('type', type);
        transactions.add(filter, relations);
    });
    return transactions;
}
function buildInputFilter(dataRequest) {
    let inputs = new util_internal_processor_tools_1.EntityFilter();
    dataRequest.inputs?.forEach(req => {
        let { type, coinOwner, coinAssetId, contractContractId, messageSender, messageRecipient, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('type', req.type);
        filter.getIn(input => input.type == 'InputCoin' && (0, util_internal_1.assertNotNull)(input.owner), coinOwner);
        filter.getIn(input => input.type == 'InputCoin' && (0, util_internal_1.assertNotNull)(input.assetId), coinAssetId);
        filter.getIn(input => input.type == 'InputContract' && (0, util_internal_1.assertNotNull)(input.contractId), contractContractId);
        filter.getIn(input => input.type == 'InputMessage' && (0, util_internal_1.assertNotNull)(input.sender), messageSender);
        filter.getIn(input => input.type == 'InputMessage' && (0, util_internal_1.assertNotNull)(input.recipient), messageRecipient);
        inputs.add(filter, relations);
    });
    return inputs;
}
function buildOutputFilter(dataRequest) {
    let outputs = new util_internal_processor_tools_1.EntityFilter();
    dataRequest.outputs?.forEach(req => {
        let { type, ...relations } = req;
        let filter = new util_internal_processor_tools_1.FilterBuilder();
        filter.propIn('type', type);
        outputs.add(filter, relations);
    });
    return outputs;
}
const getItemFilter = (0, util_internal_1.weakMemo)((dataRequest) => {
    return {
        receipts: buildReceiptFilter(dataRequest),
        transactions: buildTransactionFilter(dataRequest),
        inputs: buildInputFilter(dataRequest),
        outputs: buildOutputFilter(dataRequest),
    };
});
function filterBlock(block, dataRequest) {
    let items = getItemFilter(dataRequest);
    let include = new IncludeSet();
    let transactions = new Map(block.transactions.map(tx => [tx.index, tx]));
    let inputsByTx = (0, util_internal_1.groupBy)(block.inputs, input => input.transactionIndex);
    let outputsByTx = (0, util_internal_1.groupBy)(block.outputs, ouput => ouput.transactionIndex);
    let receiptsByTx = (0, util_internal_1.groupBy)(block.receipts, receipt => receipt.transactionIndex);
    if (items.receipts.present()) {
        for (let receipt of block.receipts) {
            let rel = items.receipts.match(receipt);
            if (rel == null)
                continue;
            include.addReceipt(receipt);
            if (rel.transaction) {
                let tx = (0, util_internal_1.assertNotNull)(transactions.get(receipt.transactionIndex));
                include.addTransaction(tx);
            }
        }
    }
    if (items.transactions.present()) {
        for (let tx of block.transactions) {
            let rel = items.transactions.match(tx);
            if (rel == null)
                continue;
            include.addTransaction(tx);
            if (rel.receipts) {
                let receipts = (0, util_internal_1.assertNotNull)(receiptsByTx.get(tx.index));
                for (let receipt of receipts) {
                    include.addReceipt(receipt);
                }
            }
            if (rel.inputs) {
                let inputs = (0, util_internal_1.assertNotNull)(inputsByTx.get(tx.index));
                for (let input of inputs) {
                    include.addInput(input);
                }
            }
            if (rel.outputs) {
                let outputs = (0, util_internal_1.assertNotNull)(outputsByTx.get(tx.index));
                for (let output of outputs) {
                    include.addOutput(output);
                }
            }
        }
    }
    if (items.inputs.present()) {
        for (let input of block.inputs) {
            let rel = items.inputs.match(input);
            if (rel == null)
                continue;
            include.addInput(input);
            if (rel.transaction) {
                let tx = (0, util_internal_1.assertNotNull)(transactions.get(input.transactionIndex));
                include.addTransaction(tx);
            }
        }
    }
    if (items.outputs.present()) {
        for (let output of block.outputs) {
            let rel = items.outputs.match(output);
            if (rel == null)
                continue;
            include.addOutput(output);
            if (rel.transaction) {
                let tx = (0, util_internal_1.assertNotNull)(transactions.get(output.transactionIndex));
                include.addTransaction(tx);
            }
        }
    }
    block.receipts = block.receipts.filter(receipt => include.receipts.has(receipt));
    block.transactions = block.transactions.filter(tx => include.transactions.has(tx));
    block.inputs = block.inputs.filter(input => include.inputs.has(input));
    block.outputs = block.outputs.filter(output => include.outputs.has(output));
}
exports.filterBlock = filterBlock;
function filterBlockBatch(requests, blocks) {
    for (let block of blocks) {
        let dataRequest = (0, util_internal_range_1.getRequestAt)(requests, block.header.height) || NO_DATA_REQUEST;
        filterBlock(block, dataRequest);
    }
}
exports.filterBlockBatch = filterBlockBatch;
const NO_DATA_REQUEST = {};
//# sourceMappingURL=filter.js.map