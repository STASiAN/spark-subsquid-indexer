"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSourceBuilder = void 0;
const http_client_1 = require("@subsquid/http-client");
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_archive_client_1 = require("@subsquid/util-internal-archive-client");
const util_internal_processor_tools_1 = require("@subsquid/util-internal-processor-tools");
const util_internal_range_1 = require("@subsquid/util-internal-range");
const data_source_1 = require("@subsquid/fuel-data/lib/data-source");
const assert_1 = __importDefault(require("assert"));
const source_1 = require("./archive/source");
const fields_1 = require("./fields");
const graphql_1 = require("./graphql");
class DataSourceBuilder {
    constructor() {
        this.requests = [];
        this.running = false;
    }
    assertNotRunning() {
        if (this.running) {
            throw new Error('Settings modifications are not allowed after start of processing');
        }
    }
    /**
     * Set Subsquid Network Gateway endpoint (ex Archive).
     *
     * Subsquid Network allows to get data from finalized blocks up to
     * infinite times faster and more efficient than via regular GraphQL.
     *
     * @example
     * processor.setGateway('https://v2.archive.subsquid.io/network/fuel-mainnet')
     */
    setGateway(url) {
        this.assertNotRunning();
        if (typeof url == 'string') {
            this.gateway = { url };
        }
        else {
            this.gateway = url;
        }
        return this;
    }
    /**
     * Set up GraphQL data ingestion
     */
    setGraphql(settings) {
        this.assertNotRunning();
        this.graphql = settings;
        return this;
    }
    /**
     * Limits the range of blocks to be processed.
     *
     * When the upper bound is specified,
     * the processor will terminate with exit code 0 once it reaches it.
     */
    setBlockRange(range) {
        this.assertNotRunning();
        this.blockRange = range;
        return this;
    }
    /**
     * Configure a set of fetched fields
     */
    setFields(fields) {
        this.assertNotRunning();
        this.fields = fields;
        return this;
    }
    add(range, request) {
        this.requests.push({
            range: range || { from: 0 },
            request
        });
    }
    /**
     * By default, the processor will fetch only blocks
     * which contain requested items. This method
     * modifies such behaviour to fetch all chain blocks.
     *
     * Optionally a range of blocks can be specified
     * for which the setting should be effective.
     */
    includeAllBlocks(range) {
        this.assertNotRunning();
        this.add(range, { includeAllBlocks: true });
        return this;
    }
    addTransaction(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add(range, {
            transactions: [req]
        });
        return this;
    }
    addReceipt(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add(range, {
            receipts: [req]
        });
        return this;
    }
    addInput(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add(range, {
            inputs: [req]
        });
        return this;
    }
    addOutput(options) {
        this.assertNotRunning();
        let { range, ...req } = options;
        this.add(range, {
            outputs: [req]
        });
        return this;
    }
    getRequests() {
        function concat(a, b) {
            let result = [];
            if (a) {
                result.push(...a);
            }
            if (b) {
                result.push(...b);
            }
            return result.length == 0 ? undefined : result;
        }
        let requests = (0, util_internal_range_1.mergeRangeRequests)(this.requests, (a, b) => {
            return {
                includeAllBlocks: a.includeAllBlocks || b.includeAllBlocks,
                transactions: concat(a.transactions, b.transactions),
                receipts: concat(a.receipts, b.receipts),
                inputs: concat(a.inputs, b.inputs),
                outputs: concat(a.outputs, b.outputs),
            };
        });
        let fields = (0, fields_1.getFields)(this.fields);
        requests = requests.map(({ range, request }) => {
            return {
                range,
                request: {
                    fields,
                    ...request
                }
            };
        });
        return (0, util_internal_range_1.applyRangeBound)(requests, this.blockRange);
    }
    build() {
        return new FuelDataSource(this.getRequests(), this.gateway, this.graphql);
    }
}
exports.DataSourceBuilder = DataSourceBuilder;
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], DataSourceBuilder.prototype, "getRequests", null);
class FuelDataSource {
    constructor(requests, gatewaySettings, graphqlSettings) {
        this.requests = requests;
        this.gatewaySettings = gatewaySettings;
        (0, assert_1.default)(this.gatewaySettings || graphqlSettings, 'either gateway or GraphQL should be provided');
        if (graphqlSettings) {
            this.graphql = this.createGraphqlDataSource(graphqlSettings);
        }
        this.ranges = this.requests.map(req => req.range);
    }
    getFinalizedHeight() {
        if (this.graphql) {
            return this.graphql.getFinalizedHeight();
        }
        else {
            return this.createGateway().getFinalizedHeight();
        }
    }
    async getBlockHash(height) {
        await this.assertConsistency();
        if (this.gatewaySettings == null) {
            (0, assert_1.default)(this.graphql);
            return this.graphql.getBlockHash(height);
        }
        else {
            let gateway = this.createGateway();
            let head = await gateway.getFinalizedHeight();
            if (head >= height)
                return gateway.getBlockHash(height);
            if (this.graphql)
                return this.graphql.getBlockHash(height);
        }
    }
    async assertConsistency() {
        if (this.isConsistent || this.gatewaySettings == null || this.graphql == null)
            return;
        let blocks = await this.performConsistencyCheck().catch(err => {
            throw (0, util_internal_1.addErrorContext)(new Error(`Failed to check consistency between Subsquid Gateway and GraphQL endpoints`), { reason: err });
        });
        if (blocks == null) {
            this.isConsistent = true;
        }
        else {
            throw (0, util_internal_1.addErrorContext)(new Error(`Provided Subsquid Gateway and GraphQL endpoints don't agree on block â„–${blocks.archiveBlock.height}`), blocks);
        }
    }
    async performConsistencyCheck() {
        let archive = this.createGateway();
        let height = await archive.getFinalizedHeight();
        let archiveBlock = await archive.getBlockHeader(height);
        let gqlBlock = await this.graphql.getBlockHeader(archiveBlock.height);
        if (gqlBlock?.id === archiveBlock.hash && Number(gqlBlock.height) === archiveBlock.height)
            return;
        return { archiveBlock, gqlBlock: gqlBlock || null };
    }
    getBlocksCountInRange(range) {
        return (0, util_internal_range_1.getSize)(this.ranges, range);
    }
    async *getBlockStream(fromBlockHeight) {
        await this.assertConsistency();
        let requests = fromBlockHeight == null
            ? this.requests
            : (0, util_internal_range_1.applyRangeBound)(this.requests, { from: fromBlockHeight });
        if (requests.length == 0)
            return;
        if (this.gatewaySettings) {
            let agent = new http_client_1.HttpAgent({ keepAlive: true });
            try {
                let archive = this.createGateway(agent);
                let height = await archive.getFinalizedHeight();
                let from = requests[0].range.from;
                if (height > from || !this.graphql) {
                    for await (let batch of archive.getBlockStream(requests, !!this.graphql)) {
                        yield batch;
                        from = (0, util_internal_1.last)(batch).header.height + 1;
                    }
                    requests = (0, util_internal_range_1.applyRangeBound)(requests, { from });
                }
            }
            finally {
                agent.close();
            }
        }
        if (requests.length == 0)
            return;
        (0, assert_1.default)(this.graphql);
        yield* this.graphql.getBlockStream(requests);
    }
    createGateway(agent) {
        (0, assert_1.default)(this.gatewaySettings);
        let http = new http_client_1.HttpClient({
            headers: {
                'x-squid-id': this.getSquidId()
            },
            agent
        });
        return new source_1.FuelGateway(new util_internal_archive_client_1.ArchiveClient({
            http,
            url: this.gatewaySettings.url,
            queryTimeout: this.gatewaySettings.requestTimeout,
        }));
    }
    createGraphqlDataSource(settings) {
        let dataSource = new data_source_1.HttpDataSource({
            client: new http_client_1.HttpClient({ baseUrl: settings.url }),
            strideConcurrency: settings.strideConcurrency,
            strideSize: settings.strideSize,
        });
        return new graphql_1.GraphqlDataSource(dataSource);
    }
    getSquidId() {
        return (0, util_internal_processor_tools_1.getOrGenerateSquidId)();
    }
}
__decorate([
    util_internal_1.def,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", String)
], FuelDataSource.prototype, "getSquidId", null);
//# sourceMappingURL=source.js.map