"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuelGateway = void 0;
const util_internal_1 = require("@subsquid/util-internal");
const util_internal_ingest_tools_1 = require("@subsquid/util-internal-ingest-tools");
const util_internal_range_1 = require("@subsquid/util-internal-range");
const util_internal_validation_1 = require("@subsquid/util-internal-validation");
const assert_1 = __importDefault(require("assert"));
const data_schema_1 = require("./data-schema");
class FuelGateway {
    constructor(client) {
        this.client = client;
    }
    getFinalizedHeight() {
        return this.client.getHeight();
    }
    async getBlockHash(height) {
        let blocks = await this.client.query({
            type: 'fuel',
            fromBlock: height,
            toBlock: height,
            includeAllBlocks: true
        });
        (0, assert_1.default)(blocks.length == 1);
        return blocks[0].header.hash;
    }
    async getBlockHeader(height) {
        let blocks = await this.client.query({
            type: 'fuel',
            fromBlock: height,
            toBlock: height,
            includeAllBlocks: true,
            fields: {
                block: {
                    daHeight: true,
                    transactionsRoot: true,
                    transactionsCount: true,
                    messageReceiptCount: true,
                    prevRoot: true,
                    time: true,
                    applicationHash: true,
                    eventInboxRoot: true,
                    consensusParametersVersion: true,
                    stateTransitionBytecodeVersion: true,
                    messageOutboxRoot: true
                }
            }
        });
        (0, assert_1.default)(blocks.length == 1);
        let { number, ...rest } = blocks[0].header;
        return {
            height: number,
            ...rest
        };
    }
    async *getBlockStream(requests, stopOnHead) {
        let archiveRequests = (0, util_internal_range_1.mapRangeRequestList)(requests, req => {
            let { fields, ...items } = req;
            return {
                type: 'fuel',
                fields,
                ...items
            };
        });
        for await (let batch of (0, util_internal_ingest_tools_1.archiveIngest)({
            client: this.client,
            requests: archiveRequests,
            stopOnHead
        })) {
            let req = (0, util_internal_range_1.getRequestAt)(requests, batch.blocks[0].header.number);
            let blocks = (0, util_internal_validation_1.cast)((0, util_internal_validation_1.array)((0, data_schema_1.getDataSchema)((0, util_internal_1.assertNotNull)(req?.fields))), batch.blocks).map(b => {
                let { header: { number, ...hdr }, ...items } = b;
                return {
                    header: { height: number, ...hdr },
                    ...items
                };
            });
            yield blocks;
        }
    }
}
exports.FuelGateway = FuelGateway;
//# sourceMappingURL=source.js.map